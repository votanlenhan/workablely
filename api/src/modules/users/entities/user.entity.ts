import { Entity, Column, Index, BeforeInsert, OneToMany, ManyToMany, JoinTable } from 'typeorm';
import { BaseEntity } from '../../../core/database/base.entity';
import * as bcrypt from 'bcrypt';
import { Role } from '../../roles/entities/role.entity';
import { ShowAssignment } from '../../show-assignments/entities/show-assignment.entity'; // Corrected path
import { Payment } from '../../payments/entities/payment.entity'; // Import Payment
import { EquipmentAssignment } from '@/modules/equipment-assignments/entities/equipment-assignment.entity'; // Added import
import { ExternalIncome } from '@/modules/external-incomes/entities/external-income.entity'; // Added import
// import { UserRole } from './user-role.entity'; // Removed import
// import { RolePermission } from '../../roles/entities/role-permission.entity'; // Removed import
// import { v4 as uuidv4 } from 'uuid'; // uuid is generated by BaseEntity now

/**
 * Represents a user in the system.
 */
@Entity({ name: 'users' }) // Explicitly set table name
export class User extends BaseEntity {
  @Column({ type: 'varchar', unique: true, nullable: false })
  @Index() // Add index for faster lookups
  email: string;

  @Column({ type: 'varchar', nullable: false, select: false })
  password_hash: string;

  @Column({ type: 'varchar', nullable: false })
  first_name: string;

  @Column({ type: 'varchar', nullable: false })
  last_name: string;

  // Consider making this a virtual column or generated in DB if supported easily,
  // otherwise, can be generated in service/getter.
  // @Column({ generated: 'CONCAT(first_name, \' \', last_name)', asExpression: 'CONCAT(first_name, \' \', last_name)' })
  // full_name: string;

  @Column({ type: 'varchar', nullable: true })
  phone_number?: string | null; // Made optional and nullable consistent with schema

  @Column({ type: 'varchar', nullable: true })
  avatar_url?: string | null; // Made optional and nullable consistent with schema

  @Column({ type: 'boolean', default: true, nullable: false })
  is_active: boolean;

  @Column({ type: 'timestamp with time zone', nullable: true })
  last_login_at?: Date | null; // Made optional and nullable consistent with schema

  // Roles relationship (owning side of the Many-to-Many)
  @ManyToMany(() => Role, (role) => role.users, {
    cascade: ['insert', 'update'], // Or adjust cascade options as needed
    // eager: true, // Uncomment if you often need roles when fetching users
  })
  @JoinTable({
    name: 'user_roles', // Matches the migration/schema
    joinColumn: { name: 'user_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'role_id', referencedColumnName: 'id' },
  })
  roles: Role[];

  // Add relation to ShowAssignment
  @OneToMany(() => ShowAssignment, (assignment: ShowAssignment) => assignment.user)
  assignments: ShowAssignment[];

  @OneToMany(() => ShowAssignment, (assignment: ShowAssignment) => assignment.assignedBy)
  assignedShowAssignments: ShowAssignment[];

  @OneToMany(() => Payment, (payment) => payment.recordedBy)
  recordedPayments: Payment[];

  // Equipment assignments where this user is the one the equipment is assigned TO
  @OneToMany(() => EquipmentAssignment, (assignment) => assignment.assigned_to_user)
  equipment_assignments_as_assignee: EquipmentAssignment[];

  // Equipment assignments that this user CREATED/ASSIGNED
  @OneToMany(() => EquipmentAssignment, (assignment) => assignment.assigned_by_user)
  equipment_assignments_as_assigner: EquipmentAssignment[];

  @OneToMany(() => ExternalIncome, (income) => income.recorded_by_user)
  recorded_external_incomes: ExternalIncome[]; // Added relation

  @BeforeInsert()
  async hashPasswordBeforeInsert() {
    // Hash password only if it's provided and not already hashed
    // This handles cases where we might create users with pre-hashed passwords
    if (this.password_hash && !this.password_hash.startsWith('$2b$')) {
      // Basic check if likely hashed
      const saltRounds = 10; // Consider moving to config
      this.password_hash = await bcrypt.hash(this.password_hash, saltRounds);
    }
  }

  // Method to manually hash a password (e.g., when updating)
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 10; // Consider moving to config
    return bcrypt.hash(password, saltRounds);
  }

  // Helper method (not a DB column) to compare password
  async validatePassword(password: string): Promise<boolean> {
    if (!this.password_hash) return false;
    return bcrypt.compare(password, this.password_hash);
  }

  // Optional: Getter for full name
  get full_name(): string {
    return `${this.first_name} ${this.last_name}`.trim();
  }

  // Constructor removed as TypeORM handles object creation
}

// Define and export a type for plain user data excluding sensitive info, methods, and relations
export type PlainUser = Omit<
  User,
  | 'password_hash'
  | 'hashPasswordBeforeInsert'
  | 'hashPassword'
  | 'validatePassword'
  | 'full_name' // If the getter exists
  | 'assignments' // Exclude relation
  | 'assignedShowAssignments' // Exclude relation
  | 'recordedPayments' // Exclude new relation from PlainUser
  | 'equipment_assignments_as_assignee' // Exclude new relation
  | 'equipment_assignments_as_assigner' // Exclude new relation
  | 'recorded_external_incomes' // Exclude new relation from PlainUser
>;
